//
//  SeeJourneyView.swift
//  Share Your Journey
//
//  Created by Bartosz Klimek on 04/03/2022.
//

import SwiftUI
import MapKit
import Firebase
import RevenueCat

class Subscription: ObservableObject {
    @Published var subscriber: Bool = false
    @Published var showPanel: Bool = false
}

//Struct contains code responsible for generating screen showing users journey they want to view.
struct SeeJourneyView: View {
    @StateObject private var subscription = Subscription()
    @Environment(\.colorScheme) var colorScheme
    @ObservedObject private var network = NetworkManager()
    
    //Similar variable described in SumUpView struct.
    let layout = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    //Enum's cases control how users view journey's photos at the particular moment.
    enum ViewType {
        case photoAlbum
        case threeDimensional
    }
    
    //Variable controls if users want to receive walking or driving directions.
    @State var walking = false
    
    //Object necessary for tracking user's location.
    @StateObject private var currentLocationManager = CurrentLocationManager()
    
    //Variable is set to one of ViewType enum's cases.
    @State private var viewMode = ViewType.photoAlbum
    
    //journey that is currently viewed by the user.
    @State var journey: SingleJourney
    
    //all locations that are assigned to photos taken by user.
    @State private var locations: [PhotoLocation] = []
    
    //Similar variables were described in SumUpView struct.
    @State private var highlightedPhotoIndex = 0
    @State private var showPicture = false
    @State private var savedToCameraRoll = false
    @State private var highlightedPhoto: UIImage = UIImage()
    @State private var downloadedPhotos = false
    @State private var showDownloadAlert = false
    
    //Variable controls if the journey can be found in user's downloaded journeys in the server.
    @State private var alreadyDownloaded = false
    
    //Variable's value justifies if users want to change journeys's name before downloading it (if journey's name duplicates.
    @State private var changeName = false
    
    //Variable's value justifies if journey was downloading after changing its name (if duplication occured).
    @State private var downloadChangedJourney = false
    
    //Variable's value contains data about journey's new name (after changing it because of duplication).
    @State private var journeyNewName = ""
    
    //Variable checks if presented journey was already downloaded (not to be mistaken with "areadyDownloaded which search for duplication in the Core Data).
    @State private var journeyIsDownloaded = false
    
    @State private var showSendingView = false
    
    @State private var showWeather = false
    @State private var expandWeather = false
    @State private var weatherLatitude = 0.0
    @State private var weatherLongitude = 0.0
    
    //Variable is responsible for saving data to Core Data.
    @Environment(\.managedObjectContext) var moc
    
    //Variable is meant to contain downloaded journeys.
    @FetchRequest(entity: Journey.entity(), sortDescriptors: [], predicate: nil, animation: nil) var journeys: FetchedResults<Journey>
    
    //Journey owner's email address.
    var email: String
    
    //Variable checks if program is showing downloaded (Core Data) journey or the journey from the server.
    var downloadMode: Bool
    var path: String
    
    var buttonColor: Color {
        colorScheme == .dark ? .white : .accentColor
    }
    
    var gold: Color {
        Color(uiColor: UIColor(red: 0.90, green: 0.42, blue: 0.00, alpha: 1.00))
    }
    
    var body: some View {
        
        VStack {
            
            //Screen generated by the code below is very similar to the screen presented by SumUpView struct.
            JourneyPickerView(choice: $viewMode, firstChoice: "Album", secondChoice: "Repeat The Journey")
                .padding(.horizontal, 5)

            if viewMode == .photoAlbum {
                ZStack {
                    VStack {
                        if !downloadedPhotos {
                            DownloadGalleryButton(journey: journey, showDownloadAlert: $showDownloadAlert, showPicture: $showPicture, subscriber: $subscription.subscriber, showPanel: $subscription.showPanel)
                        }
                        
                        PhotosAlbumView(showPicture: $showPicture, photoIndex: $highlightedPhotoIndex, highlightedPhoto: $highlightedPhoto, layout: layout, singleJourney: journey)
                            .padding(.horizontal, 5)
                        
                    }
                    .alert("Download all images", isPresented: $showDownloadAlert) {
                        Button("Cancel", role: .cancel){}
                        Button("Download") {
                            for photo in journey.photos.map({return $0.photo}) {
                                
                                //Each photo is saved to camera roll.
                                UIImageWriteToSavedPhotosAlbum(photo, nil, nil, nil)
                            }
                            withAnimation {
                                downloadedPhotos = true
                            }
                        }
                    } message: {
                        Text("Are you sure that you want to download all images to your gallery?")
                    }
                    HighlightedPhoto(savedToCameraRoll: $savedToCameraRoll, highlightedPhotoIndex: $highlightedPhotoIndex, showPicture: $showPicture, highlightedPhoto: $highlightedPhoto, subscriber: $subscription.subscriber, showPanel: $subscription.showPanel, journey: journey)
                }
            } else {
                ZStack {
                    if journey.photosLocations.count < journey.numberOfPhotos {
                        VStack {
                            Spacer()
                            Text("Unable to show the journey")
                                .foregroundColor(.gray)
                                .font(.system(size: 20))
                            Spacer()
                        }
                    } else {
                        
                        ZStack {
                            MapView(walking: $walking, showPhoto: $showPicture, photoIndex: $highlightedPhotoIndex, showWeather: $showWeather, expandWeather: $expandWeather, weatherLatitude: $weatherLatitude, weatherLongitude: $weatherLongitude, photos: journey.photos.sorted{$1.number > $0.number}.map{$0.photo}, photosLocations: journey.photosLocations)
                                .edgesIgnoringSafeArea(.all)
                                .environmentObject(currentLocationManager)
                                .opacity(showPicture ? 0 : 1)
                            
                            if showWeather {
                                VStack {
                                    HStack {
                                        if expandWeather {
                                            WeatherView(latitude: weatherLatitude, longitude: weatherLongitude)
                                                .padding()
                                        } else {
                                            Button{
                                                withAnimation(.easeInOut(duration: 0.15)) {
                                                    expandWeather = true
                                                }
                                            }label: {
                                                MapButton(imageName: "cloud.sun.fill")
                                                    .foregroundColor(colorScheme == .light ? .accentColor : .white)
                                                    .padding()
                                            }
                                        }
                                        Spacer()
                                    }
                                    Spacer()
                                }
                                .opacity(showPicture ? 0 : 1)
                            }
                        }
                    }
                    if !showPicture {
                        HStack {
                            VStack {
                                Spacer()
                                
                                if !downloadMode && !journeyIsDownloaded {
                                    if journey.photos.map ({return $0.photo}).contains(UIImage()) {
                                        ProgressView()
                                            .padding(.vertical)
                                    } else {
                                        Button{
                                            if subscription.subscriber {
                                                if journeys.map({$0.name}).contains(journey.name) {
                                                    alreadyDownloaded = true
                                                    return
                                                }
                                                downloadJourney(name: journey.name)
                                                withAnimation {
                                                    journeyIsDownloaded = true
                                                }
                                            } else {
                                                subscription.showPanel = true
                                            }
                                        } label: {
                                            MapButton(imageName: "square.and.arrow.down")
                                                .foregroundColor(subscription.subscriber ? buttonColor : gold)
                                        }
                                        
                                    }
                                } else if downloadMode && journey.networkProblem {
                                    Button{
                                        
                                        if network.connected {
                                            createJourney()
                                            
                                            for i in journeys {
                                                if i.name == journey.name {
                                                    moc.delete(i)
                                                    try? moc.save()
                                                    break
                                                }
                                            }
                                            
                                            
                                            withAnimation {
                                                journey.networkProblem = false
                                            }
                                        }
                                        
                                    } label: {
                                        MapButton(imageName: "plus")
                                            .foregroundColor(colorScheme == .light ? Color.accentColor : .white)
                                    }
                                }
                                
                                //Icons enabling users to choose between walking and driving directions.
                                DirectionIcons(mapType: $currentLocationManager.mapView.mapType, subscriber: $subscription.subscriber, showPanel: $subscription.showPanel, walking: $walking)
                                
                                //Buttons enabling users to re-center the map and change map's mode.
                                Button {
                                    currentLocationManager.changeTypeOfMap()
                                } label: {
                                    MapTypeButton()
                                }
                                .foregroundColor(buttonColor)
                                
                                
                                Button {
                                    currentLocationManager.recenterLocation()
                                } label: {
                                    LocationButton()
                                }
                                .foregroundColor(buttonColor)
                            }
                            Spacer()
                        }
                        .padding()
                        
                    }
                    HighlightedPhoto(savedToCameraRoll: $savedToCameraRoll, highlightedPhotoIndex: $highlightedPhotoIndex, showPicture: $showPicture, highlightedPhoto: $highlightedPhoto, subscriber: $subscription.subscriber, showPanel: $subscription.showPanel, journey: journey)
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button{
                    showSendingView = true
                }label:{
                    Image(systemName: "square.and.arrow.up")
                }
            }
        }
        .task {
            Purchases.shared.getCustomerInfo { (customerInfo, error) in
                if customerInfo!.entitlements["allfeatures"]?.isActive == true {
                    subscription.subscriber = true
                }
            }
        }
        .onAppear {
            if journey.photosLocations.count == 0 {
                //Depending on journey mode, program will fetch data from different source.
                if !downloadMode {
                    getJourneyDetails()
                } else {
                    getDownloadedJourneyDetails()
                }
            }
        }
        .alert(isPresented: $alreadyDownloaded) {
            
            //Alert is triggered if journey with the same name is already downloaded to Core Data.
            Alert(title: Text("Journey with the same name"),
                  message: Text("Journey with the same name is already downloaded. Do you want to provide different name to this journey?"),
                  primaryButton: .default(Text("Ok")) {
                alreadyDownloaded = false
                changeName = true
            },
                  secondaryButton: .destructive(Text("Cancel")) {
                alreadyDownloaded = false
            })
        }
        .fullScreenCover(isPresented: $subscription.showPanel, content: {
            SubscriptionView(subscriber: $subscription.subscriber)
        })
        .sheet(isPresented: $showSendingView, content: {
            SendViewedJourneyView(journey: journey)
        })
        .sheet(isPresented: $changeName, onDismiss: {
            
            //Sheet is presented to users if they choose to change duplicated journey's name.
            if downloadChangedJourney {
                downloadChangedJourney = false
                downloadJourney(name: journeyNewName)
                withAnimation {
                    journeyIsDownloaded = true
                }
                journeyNewName = ""
            }
        }, content: {
            DownloadChangesView(presentSheet: $changeName, download: $downloadChangedJourney, newName: $journeyNewName)
        })
        .navigationBarTitle(journey.name, displayMode: .inline)
    }
    
    /**
     Function is responsible for pulling journey's data from the firebase database and storage.
     */
    func getJourneyDetails() {
        let fullPhotosPath = "\(path)/\(journey.name)/photos"
        FirebaseSetup.firebaseInstance.db.collection(fullPhotosPath).getDocuments { (querySnapshot, error) in
            if error != nil {
                print(error!.localizedDescription)
            } else {
                
                preparePhotosArray()
                for i in querySnapshot!.documents.sorted(by: { $1["photoNumber"] as! Int > $0["photoNumber"] as! Int }) {
                    downloadPhotoDetails(queryDocumentSnapshot: i)
                }
            }
        }
    }
    
    /**
     Function is responsible for pulling journey's data from the Core Data.
     */
    func getDownloadedJourneyDetails() {
        for i in journeys {
            if i.name == journey.name {
                journey.email = FirebaseSetup.firebaseInstance.auth.currentUser?.email ?? ""
                journey.numberOfPhotos = i.photosArray.count
                
                for index in 0...i.photosArray.count - 1 {
                    let singlePhoto = SinglePhoto(number: index, photo: i.photosArray[index].getImage)
                    journey.photos.append(singlePhoto)
                    journey.photosLocations.append(CLLocationCoordinate2D(latitude: i.photosArray[index].latitude, longitude: i.photosArray[index].longitude))
                }
                break
            }
        }
    }
    
    /**
     Function is responsible for filling photos array with null UIImage objects. Thanks to this users can view the journey before all images load. It usually takes less than a second but, this solution makes the application more intuitive and users can view locations before all photos load.
     */
    func preparePhotosArray() {
        if journey.numberOfPhotos != 0 {
            for _ in 0...journey.numberOfPhotos - 1 {
                journey.photos.append(SinglePhoto(number: 0, photo: UIImage()))
            }
        }
    }
    
    /**
     Function is responsible for sorting all journey's images due to their id.
     */
    func sortImages(dictionaryOfPhotos: [Int:UIImage]) -> [SinglePhoto] {
        var arrayOfImages: [SinglePhoto] = []
        
        for _ in 0...dictionaryOfPhotos.count - 1 {
            arrayOfImages.append(SinglePhoto(number: 0, photo: UIImage()))
        }
        
        for i in dictionaryOfPhotos {
            arrayOfImages[i.key] = SinglePhoto(number: i.key, photo: i.value)
        }
        return arrayOfImages
    }
    
    /**
     Function is responsible for downloading for all photo's details from the database and storage.
     */
    func downloadPhotoDetails(queryDocumentSnapshot: QueryDocumentSnapshot) {
        journey.photosLocations.append(CLLocationCoordinate2D(latitude: queryDocumentSnapshot.get("latitude") as! CLLocationDegrees, longitude: queryDocumentSnapshot.get("longitude") as! CLLocationDegrees))
        
        //Image's reverence / url is used for downloading image from storage later on.
        let photoReference = FirebaseSetup.firebaseInstance.storage.reference().child(queryDocumentSnapshot.get("photoUrl") as! String)
        
        //Image is downloaded from the storage.
        photoReference.downloadURL { url, error in
            if error != nil {
                print(error!.localizedDescription)
            } else {
                
                //URLSESSIon uses url to download image.
                URLSession.shared.dataTask(with: url!) { data, response, error in
                    guard let data = data, let image = UIImage(data: data) else {
                        return
                    }
                    
                    //Image is appended to photos array on main thread so running application isn't interrupted.
                    DispatchQueue.main.async {
                        journey.photos[queryDocumentSnapshot.get("photoNumber") as! Int] = (SinglePhoto(number: queryDocumentSnapshot.get("photoNumber") as! Int,photo: image))
                    }
                }
                .resume()
            }
        }
    }
    
    /**
     Function is responsible for saving the journey in Core Data.
     */
    func downloadJourney(name: String) {
        let newJourney = Journey(context: moc)
        
        newJourney.name = name
        newJourney.email = FirebaseSetup.firebaseInstance.auth.currentUser?.email
        newJourney.date = Date()
        newJourney.networkProblem = false
        newJourney.photosNumber = (journey.numberOfPhotos) as NSNumber
        var index = 0
        
        while index < journey.photos.count {
            let newImage = Photo(context: moc)
            newImage.id = Double(index + 1)
            newImage.journey = newJourney
            newImage.image = journey.photos[index].photo.jpegData(compressionQuality: 0.5)
            newImage.latitude = journey.photosLocations[index].latitude
            newImage.longitude = journey.photosLocations[index].longitude
            newJourney.addToPhotos(newImage)
            index+=1
        }
        
        //After all journey properties are set, changes need to be saved with context variable's function: save().
        try? moc.save()
    }
    
    /**
     Function is responsible for creating a new journey document in journeys collection in the firestore database. (Function also exists in SaveJourneyView).
     */
    func createJourney() {
        let instanceReference = FirebaseSetup.firebaseInstance
        instanceReference.db.collection("users/\(instanceReference.auth.currentUser?.email ?? "")/friends/\(instanceReference.auth.currentUser?.email ?? "")/journeys").document(journey.name).setData([
            "name" : journey.name,
            "email" : FirebaseSetup.firebaseInstance.auth.currentUser?.email ?? "",
            "photosNumber" : journey.numberOfPhotos,
            "date" : Date(),
            "deletedJourney" : false
        ])
        for index in 0...journey.photosLocations.count - 1 {
            uploadPhoto(index: index, instanceReference: instanceReference)
        }
    }
    
    /**
     Function is responsible for uploading an image to the firebase storage and adding its details to firestore database. (Function also exists in SaveJourneyView).
     */
    func uploadPhoto(index: Int, instanceReference: FirebaseSetup) {
        guard let photo = journey.photos.sorted(by: {$1.number > $0.number}).map({$0.photo})[index].jpegData(compressionQuality: 0.2) else {
            return
        }
        let metaData = StorageMetadata()
        metaData.contentType = "image/jpeg"
        let photoReference = "\(instanceReference.auth.currentUser?.email ?? "")/\(journey.name)/\(index)"
        let storageReference = instanceReference.storage.reference(withPath: photoReference)
        
        //Storage is populated with the image.
        storageReference.putData(photo, metadata: metaData) { metaData, error in
            if let error = error {
                print(error.localizedDescription)
            }
            
            //Image's details are added to appropriate collection in firetore's database.
            instanceReference.db.document("users/\(instanceReference.auth.currentUser?.email ?? "")/friends/\(instanceReference.auth.currentUser?.email ?? "")/journeys/\(journey.name)/photos/\(index)").setData([
                "latitude": journey.photosLocations[index].latitude,
                "longitude": journey.photosLocations[index].longitude,
                "photoUrl": photoReference,
                "photoNumber": index
            ])
        }
    }
}
