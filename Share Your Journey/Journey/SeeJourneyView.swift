//
//  SeeJourneyView.swift
//  Share Your Journey
//
//  Created by Bartosz Klimek on 04/03/2022.
//

import SwiftUI
import MapKit
import Firebase

//Struct contains code responsible for generating screen showing users journey they want to view.
struct SeeJourneyView: View {
    
    //Similar variable described in SumUpView struct.
    let layout = [
        GridItem(.flexible()),
        GridItem(.flexible())
    ]
    
    //Enum's cases control how users view journey's photos at the particular moment.
    enum ViewType {
        case twoDimensional
        case threeDimensional
        case photoAlbum
    }
    
    //Variable controls if users want to receive walking or driving directions.
    @State var walking = false
    
    //Object necessary for tracking user's location.
    @StateObject private var currentLocationManager = CurrentLocationManager()
    
    //Variable is set to one of ViewType enum's cases.
    @State private var viewMode = ViewType.twoDimensional
    
    //journey that is currently viewed by the user.
    @State var journey: SingleJourney
    
    //all locations that are assigned to photos taken by user.
    @State private var locations: [PhotoLocation] = []
    
    //Similar variable was described in SumUpView struct.
    @State private var initialFocus = MKCoordinateRegion(center: CLLocationCoordinate2D(), latitudinalMeters: 1000, longitudinalMeters: 1000)
    
    //Similar variables were described in SumUpView struct.
    @State private var highlightedPhotoIndex = 0
    @State private var showPicture = false
    @State private var savedToCameraRoll = false
    @State private var highlightedPhoto: UIImage = UIImage()
    @State private var downloadedPhotos = false
    
    //Variable controls if the journey can be found in user's downloaded journeys in the server.
    @State private var alreadyDownloaded = false
    
    //Variable's value justifies if users want to change journeys's name before downloading it (if journey's name duplicates.
    @State private var changeName = false
    
    //Variable's value justifies if journey was downloading after changing its name (if duplication occured).
    @State private var downloadChangedJourney = false
    
    //Variable's value contains data about journey's new name (after changing it because of duplication).
    @State private var journeyNewName = ""
    
    //Variable checks if presented journey was already downloaded (not to be mistaken with "areadyDownloaded which search for duplication in the Core Data).
    @State private var journeyIsDownloaded = false
    
    //Variable is responsible for saving data to Core Data.
    @Environment(\.managedObjectContext) var context
    
    //Variable is meant to contain downloaded journeys.
    @FetchRequest(entity: Journey.entity(), sortDescriptors: [], predicate: nil, animation: nil) var journeys: FetchedResults<Journey>
    
    //Journey owner's email address.
    var email: String
    
    //Variable checks if program is showing downloaded (Core Data) journey or the journey from the server.
    var downloadMode: Bool
    var path: String
    
    var body: some View {
        
        VStack {
            
            //Screen generated by the code below is very similar to the screen presented by SumUpView struct.
            TriplePickerView(choice: $viewMode, firstChoice: "2D", secondChoice: "3D", thirdChoice: "Album")
                .padding(.horizontal, 5)
            
            if viewMode == .twoDimensional {
                
                //If size of array containing image locations is smaller that size of array containing images data, it is because the program haven't downloaded all journey's photos or journey was opened to soon after saving it.
                if journey.photosLocations.count < journey.numberOfPhotos {
                    VStack {
                        Spacer()
                        Text("Journey isn't available yet")
                            .font(.system(size: 20))
                            .foregroundColor(.gray)
                        Spacer()
                    }
                } else {
                    ZStack {
                        Map(coordinateRegion: $initialFocus, annotationItems: journey.photosLocations.enumerated().map({return PhotoLocation(id: $0.offset, location: CLLocationCoordinate2D(latitude: $0.element.latitude, longitude: $0.element.longitude))})) { location in
                            MapAnnotation(coordinate: location.location) {
                                PhotoAnnotationView(photoIndex: $highlightedPhotoIndex, highlightedPhoto: $highlightedPhoto, showPicture: $showPicture, singleJourney: journey, location: location)
                            }
                        }
                        .onAppear {
                            initialFocus = MKCoordinateRegion(center: journey.photosLocations[0], latitudinalMeters: 1000, longitudinalMeters: 1000)
                        }
                        .opacity(showPicture ? 0 : 1)
                        
                        //Concept of showing enlarged image after user taps it is identical to concept in SumUpView struct, Both structs use the same struct to achieve this effect.
                        HighlightedPhoto(savedToCameraRoll: $savedToCameraRoll, highlightedPhotoIndex: $highlightedPhotoIndex, showPicture: $showPicture, highlightedPhoto: $highlightedPhoto, journey: journey)
                    }
                }
            } else if viewMode == .photoAlbum {
                ZStack {
                    VStack {
                        if !downloadedPhotos {
                            DownloadGalleryButton(journey: journey, showPicture: $showPicture, downloadedPhotos: $downloadedPhotos)
                        }
                        
                        PhotosAlbumView(showPicture: $showPicture, photoIndex: $highlightedPhotoIndex, highlightedPhoto: $highlightedPhoto, layout: layout, singleJourney: journey)
                            .padding(.horizontal, 5)
                        
                    }
                    
                    HighlightedPhoto(savedToCameraRoll: $savedToCameraRoll, highlightedPhotoIndex: $highlightedPhotoIndex, showPicture: $showPicture, highlightedPhoto: $highlightedPhoto, journey: journey)
                }
            } else {
                ZStack {
                    if journey.photosLocations.count < journey.numberOfPhotos {
                        VStack {
                            Spacer()
                            Text("Journey isn't available yet")
                                .foregroundColor(.gray)
                                .font(.system(size: 20))
                            Spacer()
                        }
                    } else {
                        MapView(walking: $walking, showPhoto: $showPicture, photoIndex: $highlightedPhotoIndex, photos: journey.photos.sorted{$1.number > $0.number}.map{$0.photo}, photosLocations: journey.photosLocations)
                            .edgesIgnoringSafeArea(.all)
                            .environmentObject(currentLocationManager)
                            .opacity(showPicture ? 0 : 1)
                    }
                    if !showPicture {
                        HStack {
                            VStack {
                                Spacer()
                                
                                if !downloadMode && !journeyIsDownloaded {
                                    if journey.photos.map ({return $0.photo}).contains(UIImage()) {
                                        ProgressView()
                                    } else {
                                        Button{
                                            if journeys.map({$0.name}).contains(journey.name) {
                                                alreadyDownloaded = true
                                                return
                                            }
                                            
                                            downloadJourney(name: journey.name)
                                            withAnimation {
                                                journeyIsDownloaded = true
                                            }
                                        } label: {
                                            Image(systemName: "square.and.arrow.down")
                                                .font(.system(size: 30))
                                                .foregroundColor(Color.blue)
                                        }
                                        
                                    }
                                }
                                
                                //Icons enabling users to choose between walking and driving directions.
                                DirectionIcons(walking: $walking)
                                
                                //Buttons enabling users to re-center the map and change map's mode.
                                MapButtonsView(currentLocationManager: currentLocationManager)
                            }
                            Spacer()
                        }
                        .padding()
                        
                    }
                    HighlightedPhoto(savedToCameraRoll: $savedToCameraRoll, highlightedPhotoIndex: $highlightedPhotoIndex, showPicture: $showPicture, highlightedPhoto: $highlightedPhoto, journey: journey)
                }
            }
        }
        .onAppear {
            
            //Depending on journey mode, program will fetch data from different source.
            if !downloadMode {
                getJourneyDetails()
            } else {
                getDownloadedJourneyDetails()
            }
        }
        .alert(isPresented: $alreadyDownloaded) {
            
            //Alert is triggered if journey with the same name is already downloaded to Core Data.
            Alert(title: Text("Journey with the same name"),
                  message: Text("Journey with the same name is already downloaded. Do you want to provide different name to this journey?"),
                  primaryButton: .default(Text("Ok")) {
                alreadyDownloaded = false
                changeName = true
            },
                  secondaryButton: .destructive(Text("Cancel")) {
                alreadyDownloaded = false
            })
        }
        .sheet(isPresented: $changeName, onDismiss: {
            
            //Sheet is presented to users if they choose to change duplicated journey's name.
            if downloadChangedJourney {
                downloadChangedJourney = false
                downloadJourney(name: journeyNewName)
                withAnimation {
                    journeyIsDownloaded = true
                }
                journeyNewName = ""
            }
        }, content: {
            DownloadChangesView(presentSheet: $changeName, download: $downloadChangedJourney, newName: $journeyNewName)
        })
        .navigationBarTitle(journey.name, displayMode: .inline)
    }
    
    /**
     Function is responsible for pulling journey's data from the firebase database and storage.
     */
    func getJourneyDetails() {
        let fullPhotosPath = "\(path)/\(journey.name)/photos"
        FirebaseSetup.firebaseInstance.db.collection(fullPhotosPath).getDocuments { (querySnapshot, error) in
            if error != nil {
                print(error!.localizedDescription)
            } else {
                
                preparePhotosArray()
                for i in querySnapshot!.documents.sorted(by: { $1["photoNumber"] as! Int > $0["photoNumber"] as! Int }) {
                    downloadPhotoDetails(queryDocumentSnapshot: i)
                }
            }
        }
    }
    
    /**
     Function is responsible for pulling journey's data from the Core Data.
     */
    func getDownloadedJourneyDetails() {
        for i in journeys {
            if i.name == journey.name {
                journey.email = FirebaseSetup.firebaseInstance.auth.currentUser?.email ?? ""
                journey.numberOfPhotos = i.photosArray.count
                
                for index in 0...i.photosArray.count - 1 {
                    let singlePhoto = SinglePhoto(number: index, photo: i.photosArray[index].image)
                    journey.photos.append(singlePhoto)
                    journey.photosLocations.append(CLLocationCoordinate2D(latitude: i.photosArray[index].latitude, longitude: i.photosArray[index].longitude))
                }
                break
            }
        }
    }
    
    /**
     Function is responsible for filling photos array with null UIImage objects. Thanks to this users can view the journey before all images load. It usually takes less than a second but, this solution makes the application more intuitive and users can view locations before all photos load.
     */
    func preparePhotosArray() {
        if journey.numberOfPhotos != 0 {
            for _ in 0...journey.numberOfPhotos - 1 {
                journey.photos.append(SinglePhoto(number: 0, photo: UIImage()))
            }
        }
    }
    
    /**
     Function is responsible for sorting all journey's images due to their id.
     */
    func sortImages(dictionaryOfPhotos: [Int:UIImage]) -> [SinglePhoto] {
        var arrayOfImages: [SinglePhoto] = []
        
        for _ in 0...dictionaryOfPhotos.count - 1 {
            arrayOfImages.append(SinglePhoto(number: 0, photo: UIImage()))
        }
        
        for i in dictionaryOfPhotos {
            arrayOfImages[i.key] = SinglePhoto(number: i.key, photo: i.value)
        }
        return arrayOfImages
    }
    
    /**
     Function is responsible for downloading for all photo's details from the database and storage.
     */
    func downloadPhotoDetails(queryDocumentSnapshot: QueryDocumentSnapshot) {
        journey.photosLocations.append(CLLocationCoordinate2D(latitude: queryDocumentSnapshot.get("latitude") as! CLLocationDegrees, longitude: queryDocumentSnapshot.get("longitude") as! CLLocationDegrees))
        
        //Image's reverence / url is used for downloading image from storage later on.
        let photoReference = FirebaseSetup.firebaseInstance.storage.reference().child(queryDocumentSnapshot.get("photoUrl") as! String)
        
        //Image is downloaded from the storage.
        photoReference.downloadURL { url, error in
            if error != nil {
                print(error!.localizedDescription)
            } else {
                
                //URLSESSIon uses url to download image.
                URLSession.shared.dataTask(with: url!) { data, response, error in
                    guard let data = data, let image = UIImage(data: data) else {
                        return
                    }
                    
                    //Image is appended to photos array on main thread so running application isn't interrupted.
                    DispatchQueue.main.async {
                        journey.photos[queryDocumentSnapshot.get("photoNumber") as! Int] = (SinglePhoto(number: queryDocumentSnapshot.get("photoNumber") as! Int,photo: image))
                    }
                }
                .resume()
            }
        }
    }
    
    /**
     Function is responsible for saving the journey in Core Data.
     */
    func downloadJourney(name: String) {
        let newJourney = Journey(context: context)
        
        newJourney.name = name
        newJourney.email = FirebaseSetup.firebaseInstance.auth.currentUser?.email
        newJourney.date = Date()
        newJourney.photosNumber = (journey.numberOfPhotos) as NSNumber
        var index = 0
        
        while index < journey.photos.count {
            let newImage = Photo(context: context)
            newImage.id = Double(index + 1)
            newImage.journey = newJourney
            newImage.image = journey.photos[index].photo
            newImage.latitude = journey.photosLocations[index].latitude
            newImage.longitude = journey.photosLocations[index].longitude
            newJourney.addToPhotos(newImage)
            index+=1
        }
        
        //After all journey properties are set, changes need to be saved with context variable's function: save().
        try? context.save()
    }
}
